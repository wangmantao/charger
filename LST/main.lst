C51 COMPILER V9.02   MAIN                                                                  06/24/2018 09:18:16 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Code\main.c BROWSE INCDIR(.\Libs\Include) DEFINE(FOSC_160000) DEBUG OBJECTE
                    -XTEND PRINT(.\LST\main.lst) OBJECT(.\Output\main.obj)

line level    source

   1          /*
   2             FOR Charger 2018
   3             --Pin configure--
   4                  ä¸²å£1 ä¸²å£2  Relay1 Relay2  Relay3 Relay4
   5                                (L-short) (ok)    (ng)    (ä¿æŠ¤è¡¨å¤´)
   6          
   7          
   8          */
   9          
  10          /* ------ kiell ä¸­å¼•ç”¨åŸºç¡€å¤´æ–‡ä»¶ --------*/
  11          #include "N76E003.h"
  12          #include "common.h"
  13          #include "delay.h"
  14          #include "SFR_Macro.h"
  15          #include "Function_define.h"
  16          
  17          /* ---------- å®šä¹‰1/3(å¸¸é‡) --------------*/
  18          
  19          
  20          // OKä¿¡å·
  21          #define OK_ON set_P10
  22          #define OK_OFF clr_P10
  23          // NGä¿¡å·
  24          #define NG_ON set_P11
  25          #define NG_OFF clr_P11
  26          // çŸ­è·¯å¼€å…³
  27          #define SHORT_ON set_P12
  28          #define SHORT_OFF clr_P12
  29          // å……ç”µå¼€å…³
  30          #define CHARGE_ON clr_P13       // æ¥å¸¸é—­
  31          #define CHARGE_OFF set_P13
  32          
  33          // å®šæ ¼ç”µæµå¾…æµ‹æ—¶é—´ (æ’å…¥å‡ ç§’åå¼€å§‹æµ‹)
  34          #define RATE_DELAY_TIME 7               // unit:ç§’
  35          #define RATE_MIN_CURRENT 500    // unit:mA
  36          
  37          // å®šæ ¼ç”µæµç»´æŒæ—¶é—´ (ç”µæµå€¼æ£€å‡ºåï¼Œå‡ ç§°åè½¬å…¥çŸ­è·¯æµ‹è¯•)
  38          #define SHORT_DELAY_TIME 7              // unit:ç§’
  39          #define SHORT_MAX_CURRENT 20    // unit:mA
  40          
  41          
  42          
  43          
  44          /* ---------- å®šä¹‰2/3(å˜é‡) --------------*/
  45          static unsigned int DCV_OFF = 1228;             // ç”µå‹è¾“å…¥æœ‰æ²¡æœ‰ä¸‹é™ (4.5v) (4.5/3v)/5v *4095 (å› ä¸ºå–æ 
             -·åˆ†å‹1/3)
  46          static unsigned int DCV_ON = 1638;              // ç”µå‹è¾“å…¥æœ‰æ²¡æœ‰ä¸Šé™ (6v) (6/3v)/5v *4095 (å› ä¸ºå–æ ·åˆ†å
             -‹1/3)
  47          static unsigned int DCV_BAT = 1092;             // battery (4v) (4/3v)/5v *4095 (å› ä¸ºå–æ ·åˆ†å‹1/3)
  48          static unsigned int adc_val = 0;                // adcå–æ ·å€¼
  49          //static float adc_val2 = 0;            // adc -> dc ç”µå‹è¾“å…¥
  50          static unsigned int charge_current = 0;                 // å……ç”µç”µæµ
  51          static unsigned int short_current = 0;          // å……ç”µç”µæµ
  52          static bit pass = 1;                    // æµ‹è¯•ç»“æœ
C51 COMPILER V9.02   MAIN                                                                  06/24/2018 09:18:16 PAGE 2   

  53          static bit testing = 0;                 // æµ‹è¯•ä¸­çš„æ ‡è®°
  54          static bit power_offed= 0;                      // å……ç”µå™¨é€€å‡ºæ ‡è®°(å®ƒä»…æœ‰ADCæ§åˆ¶)
  55          static bit power_on= 0;                 // å……ç”µå™¨æ¥ä¸Šæ ‡è®° (è¡¨ç¤ºå¯è¿›å…¥æµ‹è¯•çŠ¶æ€ï¼Œåœ¨jugementåç½®0)
  56          static bit first_boot= 1;                       // å……ç”µå™¨æ¥ä¸Šæ ‡è®°
  57          static bit get_current_ok= 0;                   // å·²æµ‹è¯•ç”µæµæ ‡è®°
  58          static bit time_out= 0;                         // ç­‰å¾…ä¸­æ–­å–æ•°æ®è¶…æ—¶
  59          static bit recovery_ok= 0;                      // å¤å½’ç¡®è®¤æ ‡è®°
  60          static bit adcv_ok = 0;
  61          static bit this_comp_low= 0;
  62          static bit last_comp_low= 0;
  63          static bit this_comp_hi= 0;
  64          static bit last_comp_hi= 0;
  65          static bit bat_out_ok= 0;
  66          
  67          static UINT8 order = 0;
  68          static UINT8 timer0_couter= 0;
  69          static UINT8 current_val[8] ={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  70          static UINT8 adc_res[3] = {0x00,0x00, 0x00};
  71          static UINT8 cmd[6] = {0xAA,0x55,0x02,0xFE,0x01,0x00}; // ç”µæµè¯»å–æŒ‡ä»¤ AA 55 02 FE 01 00 
  72                                                                                                                                                          //04 55 02 FE 01 00 
  73          static UINT32 adc_count = 0;
  74          void chk_power_on_again(void);
  75          
  76          
  77          /* ---------- å®šä¹‰2/3(å‡½æ•°) --------------*/
  78          
  79                  /* ---------- å‡½æ•°ç±»1/4(ä¸­æ–­) --------------*/
  80          
  81          void timer0_interrupt() interrupt 1 {
  82   1        // åœæ­¢ADC/ä¸²å£å·¥ä½œï¼Œpass = 0, è®¾ç½® get_current_ok / recovery_ok = 1
  83   1              // timer 0 å…¨å¼€æœ€å¤§50mSï¼›éœ€è¦3ç§’ï¼Œè¦60ä¸ªå¾ªç¯ã€‚
  84   1              //TR0 = 0;
  85   1              if (timer0_couter> 59) //ç»“æŸ
  86   1              {
  87   2                      timer0_couter = 0;
  88   2                      time_out= 1;    
  89   2                      clr_ET0;                //å…³é—­ä¸­æ–­ï¼Œä»¥å…å½±å“timer_delay()
  90   2              }
  91   1              else{
  92   2                      timer0_couter ++;
  93   2                      //set_TR0;
  94   2              }
  95   1      }
  96          
  97          void adc_interrupt() interrupt 11 {             
  98   1              adc_val= ADCRH; adc_val<<= 4; adc_val|= (ADCRL & 0X0F);  // 16h -> dec
  99   1              //F1: æœªåœ¨æµ‹è¯•çŠ¶æ€, å……ç”µå™¨å†æ¬¡æ’å…¥æ£€æµ‹
 100   1              if(~testing){                                   //å¼€å§‹æµ‹è¯•å‰ï¼Œæ’å…¥ç”µæºæ£€æµ‹ç”¨æ­¤æ®µ
 101   2                      chk_power_on_again();
 102   2              }
 103   1              else{                                                   // ç”µæ± è¾“å‡ºæ£€æµ‹, ç­‰å¾…æ“ä½œå‘˜æŒ‰é’®ï¼Œæ²¡æœ‰è¶…æ—¶é™åˆ¶
 104   2                      if(adc_val>DCV_BAT && P13 == 1 ){                       //  æ”¾ç”µçš„ä¸‹é™å€¼ï¼Œå’Œç”µæ± çš„æ£€æµ‹å€¼ ï¼Œç”¨åŒæ ·çš„4.5Vã€
             -‚p13=CHARGE å¸¸é—­æ‰“å¼€ï¼Œä¸å……ç”µ
 105   3      
 106   3                              if(adc_count > 50000){                                  // 1.5ç§’æŒç»­é«˜
 107   4                                      adc_count = 0;
 108   4                                      bat_out_ok = 1;
 109   4                                      clr_ADCEN;                              //      å¼€å§‹æµ‹è¯•ï¼Œåœç”¨ADC
 110   4                              }
 111   3                              else{
 112   4                              adc_count++;
 113   4                                      clr_ADCF; set_ADCS;             //æ²¡æœ‰å¤å½’ï¼Œæ¥ç€ADCæ£€æµ‹                                
C51 COMPILER V9.02   MAIN                                                                  06/24/2018 09:18:16 PAGE 3   

 114   4                              }
 115   3                      }
 116   2                      else {
 117   3                              clr_ADCF; set_ADCS;             //æ²¡æœ‰å¤å½’ï¼Œæ¥ç€ADCæ£€æµ‹
 118   3                      }
 119   2      
 120   2              }                                                               
 121   1              // ADCçš„æœ€åçŠ¶æ€ç”±ifæ®µå†…éƒ¨caseå†³å®š
 122   1      }
 123          
 124          // è·å–ç”µæµå€¼ UART0 ä¸­æ–­
 125          void uart0_interrupt() interrupt 4 {
 126   1        if(RI){
 127   2              if (order > 7)
 128   2                      order = 0;
 129   2          current_val[order] = Receive_Data_From_UART0();;  // è·å–ç”µæµç»“æœ
 130   2          //Send_Data_To_UART1( current_val[order]);
 131   2          if(order == 7){
 132   3            order = 0;
 133   3            get_current_ok =1;
 134   3          }
 135   2          else {
 136   3            order ++;
 137   3          }
 138   2          clr_RI;
 139   2        }
 140   1      
 141   1        if(TI){
 142   2              clr_TI;
 143   2        }
 144   1      }
 145          
 146          void uart1_interrup(void) interrupt 15 {
 147   1        if(TI_1){
 148   2          clr_TI_1;
 149   2        }
 150   1      }
 151          
 152                  /* ---------- å‡½æ•°ç±»2/3(é…ç½®) --------------*/
 153          void chk_power_on_again(){
 154   1              // æµ‹è¯•ç»“æŸï¼Œè¦æ‹”æ‰ç”µæºï¼Œæ‰èƒ½æœ‰ä»¥ä¸‹åŠ¨ä½œ
 155   1              // æ‰€ä»¥è¦å…ˆæ£€æŸ¥ADC æœ‰ä¸€ä¸ªä½ç”µå‹ï¼Œä¹‹åå†æœ‰ä¸€ä¸ªé«˜ç”µå‹ï¼Œæ‰è®¤ä¸ºæ˜¯æœ‰æ•ˆçš„power_on
 156   1              if (first_boot && (adc_val > DCV_ON )){                 //case 1: å¼€æœºæ—¶æœ‰ç”µæº -> å¯ä»¥é©¬ä¸Šå¼€å§‹æµ‹è¯•
 157   2                      power_on = 1;
 158   2                      CHARGE_ON;
 159   2                      //SBUF=0X11;
 160   2                      clr_ADCEN;                      // å¼€å§‹æµ‹è¯•ï¼Œåœç”¨ADC
 161   2              }
 162   1              else {                                                                          //case 2: å¼€æœºæ—¶æ— ç”µæº -> åŒä¸€èˆ¬æƒ…å†µ ->å…ˆæ£€æµ‹æœ‰ä½ï¼Œå†æ£€æµ‹æœ‰é«˜
 163   2      
 164   2                      if (~power_offed && adc_val < DCV_OFF ){                                        //              åˆ¤æ–­poweroffedçš„ä¸¤ç§æƒ…å†µ
 165   3                              this_comp_low = 1;
 166   3                              if(this_comp_low != last_comp_low){             // è¦é˜²é”™æŠ–åŠ¨, ä¸ä¸Šæ¬¡ä¸åŒå°±è¦é‡æ–°è®¡æ•°
 167   4                                      adc_count =0;
 168   4                              }
 169   3                              else
 170   3                                      adc_count ++;
 171   3                              if(adc_count > 50000){                          // 1.5ç§’å†…ä¸€ç›´å°ç”µå‹, ä¿è¯æ‹”æ‰å……ç”µå™¨æ—¶ï¼Œæ¥è§¦ä¸è‰¯æœ‰é«˜ç”
             -µå‹è¯¯åˆ¤è€Œ restJugement
 172   4                                      power_offed = 1;        
 173   4                                      adc_count = 0;
 174   4                              }                               
C51 COMPILER V9.02   MAIN                                                                  06/24/2018 09:18:16 PAGE 4   

 175   3                      }
 176   2                      else{
 177   3                              this_comp_low = 0;
 178   3                      }
 179   2                      last_comp_low = this_comp_low;
 180   2      
 181   2                      // ------------ ä»¥ä¸Šä¸ºç¡®è®¤æœ‰æ•ˆçš„power_offed, ä¾›ä¸‹é¢ç”¨-------------------
 182   2      
 183   2                      if(power_offed && (adc_val > DCV_ON)){   //             ç”±power_offedçš„å†³å®šæ˜¯å¦ power_on
 184   3                              this_comp_hi = 1;
 185   3                              if(this_comp_hi != last_comp_hi){               // è¦é˜²é”™æŠ–åŠ¨, ä¸ä¸Šæ¬¡ä¸åŒå°±è¦é‡æ–°è®¡æ•°
 186   4                                      adc_count =0;
 187   4                              }
 188   3                              else
 189   3                                      adc_count ++;
 190   3                              if(adc_count > 50000){                          // 1.5ç§’å†…ä¸€ç›´å°ç”µå‹, ä¿è¯æ‹”æ‰å……ç”µå™¨æ—¶ï¼Œæ¥è§¦ä¸è‰¯æœ‰é«˜ç”
             -µå‹è¯¯åˆ¤è€Œ restJugement
 191   4                                      power_on = 1;   
 192   4                                      CHARGE_ON;
 193   4                                      adc_count = 0;
 194   4                                      clr_ADCEN;                      // å¼€å§‹æµ‹è¯•ï¼Œåœç”¨ADC     
 195   4                              }                               
 196   3                      }
 197   2                      else{
 198   3                              this_comp_hi = 0;
 199   3                      }
 200   2                      last_comp_hi = this_comp_hi;
 201   2      
 202   2                      // ------------ ä»¥ä¸Šä¸ºç¡®è®¤æœ‰æ•ˆçš„power_on, ä¾›ä¸‹é¢ç”¨-------------------
 203   2      
 204   2                      if(~power_on){                                                  // ä»¥ä¸Šæ²¡æœ‰äº§ç”Ÿæœ‰æ•ˆçš„power_on, ç»§ç»­ADC
 205   3                              clr_ADCF; set_ADCS;
 206   3                      }
 207   2              }
 208   1      }
 209          
 210          void ioConf(){
 211   1              //  å‡†åŒå‘ï¼Œå·²ç»åœ¨ä¸²å£åˆå§‹åŒ–å®šä¹‰
 212   1              //ä¸²å£1  p06 / p07
 213   1              //ä¸²å£2  p16 /p02
 214   1      
 215   1              P10_PushPull_Mode;                      // Relay 1 control - for ok -> p10
 216   1              P11_PushPull_Mode;                      // Relay 2 control - for ng -> p11
 217   1              P12_PushPull_Mode;                      // Relay 3 control - for short -> p12
 218   1              P13_PushPull_Mode;                      // Relay 4 control - for charge -> p13
 219   1              P03_Quasi_Mode;                         // ng_reset
 220   1              P04_Quasi_Mode;                         // sys_reset
 221   1              set_P03;
 222   1              set_P04;
 223   1      
 224   1      
 225   1              Enable_ADC_AIN0;                        // AIN0 P17
 226   1      
 227   1              set_PWMDIV0;                            // pwm 128åˆ†é¢‘ç‡
 228   1              set_PWMDIV1;
 229   1              set_PWMDIV2;
 230   1      }
 231          
 232          
 233                  /* ---------- å‡½æ•°ç±»3/3(åŠŸèƒ½) --------------*/
 234          
 235           void timer0_monitor_start(){
C51 COMPILER V9.02   MAIN                                                                  06/24/2018 09:18:16 PAGE 5   

 236   1              // é…ç½®å®šæ—¶æœŸåˆå€¼
 237   1              // å¼€å¯å®šæ—¶å™¨  -- > å®šæ—¶å™¨æº¢å‡ºæ—¶ï¼Œåœ¨ä¸­æ–­ä¸­å¤„ç†ï¼šåœæ­¢æµ‹è¯•ï¼Œé”™è¯¯è¾“å‡º
 238   1              time_out=0;
 239   1              order = 0;
 240   1          clr_T0M;                                            //T0M=0, Timer0 Clock = Fsys/12
 241   1          TMOD |= 0x01;                                       //Timer0 is 16-bit mode
 242   1          TL0 = 0x00;
 243   1          TH0 = 0x00;
 244   1          set_ET0;
 245   1          set_TR0;
 246   1       }
 247          
 248           void timer0_monitor_stop(){
 249   1              // å…³é—­å®šæ—¶å™¨
 250   1              TR0 = 0;
 251   1              clr_ET0;        
 252   1              // é‡ç½®å®šæ—¶å™¨çš„å€¼
 253   1       }
 254          
 255          void reset_judgement(){
 256   1              OK_OFF; NG_OFF; // ok Relay =0 ; ng Relay = 0;
 257   1      }
 258          
 259          void do_a_judgement(){
 260   1              //CHARGE_OFF;
 261   1              CHARGE_ON;
 262   1              // Timer0_Delay1ms(100);
 263   1              // 1. è¾“å‡ºæµ‹è¯•ç»“æœ(å…ˆç½®0å†ç½®1, é˜²æ­¢ä¸¤ä¸ªåŒæ—¶æœ‰æ•ˆï¼‰
 264   1              if(pass){
 265   2                      NG_OFF; 
 266   2                      OK_ON;
 267   2              }
 268   1              else {
 269   2                      OK_OFF; 
 270   2                      NG_ON;
 271   2              }
 272   1              // 2. è®¾æµ‹è¯•ç»“æŸæ ‡è®° & å¾…å¼€å§‹æ–°ä¸€è½®å……ç”µæ’å…¥æ£€æµ‹
 273   1              first_boot = 0;
 274   1              testing = 0;
 275   1              power_on = 0; 
 276   1              power_offed = 0;
 277   1      
 278   1              // 3. é‡æ–°å¼€å§‹ADCä¾¦æµ‹(å¼€å¯ADCä¸­æ–­)
 279   1              set_ADCEN;
 280   1              set_ADCS;
 281   1      }
 282          
 283          void send_cmd(){
 284   1        UINT8 order = 0;
 285   1        while (order <= 5){
 286   2          Send_Data_To_UART0(cmd[order]);
 287   2         order ++;
 288   2        }
 289   1      }
 290          
 291          void test_flow(){
 292   1        int tempV = 0;
 293   1        float current = 0;
 294   1        float re_dcv = 0;
 295   1        pass = 1;
 296   1              testing = 1;                    // æ ‡è®°è¿›å…¥æµ‹è¯•ä¸­
 297   1              reset_judgement();              // è¿›å…¥æµ‹è¯•çŠ¶è¯šåï¼ŒOK/NGç»§ç”µå™¨å¤ä½
C51 COMPILER V9.02   MAIN                                                                  06/24/2018 09:18:16 PAGE 6   

 298   1      
 299   1        // -----------------------------------------------RATE
 300   1        Timer0_Delay1ms(7000);        // Rating current
 301   1        get_current_ok = 0;
 302   1        timer0_monitor_start();
 303   1        send_cmd();
 304   1              while(~get_current_ok && ~time_out);    // Waiting A meter return
 305   1        timer0_monitor_stop();
 306   1        if(time_out){
 307   2              pass= 0;
 308   2        }
 309   1        if(get_current_ok){
 310   2              tempV = current_val[5]; tempV <<= 8; tempV |= (current_val[4] & 0xFF);
 311   2              //current =(float) ( (current_val[5] *  256 + current_val[4])/1000 );
 312   2        }
 313   1        if(~pass || tempV < 0x01F4){  // < 0.5A
 314   2        //if(~pass || tempV < 0x044c){  // < 1.1A
 315   2        // if(~pass || tempV < 0x03e8){  // < 1.0A
 316   2        //if(~pass || tempV < 0x0384){  // < .90A  
 317   2              //å‘é€å®šæ ¼æœ‰é—®é¢˜0xF1, æ£€æµ‹NGæ³¢å½¢ å’Œshortæ³¢å½¢
 318   2          pass = 0; do_a_judgement(); 
 319   2          return;   // ----> return
 320   2        }
 321   1        // -----------------------------------------------SHORT
 322   1        // åˆ‡æ–­å……ç”µå™¨
 323   1        // æ‰‹åŠ¨å¼€æœº
 324   1        //  çŸ­è·¯
 325   1        CHARGE_OFF;
 326   1        Timer0_Delay1ms(1500); //ä¿ç•™çœ‹ç”µæµçš„æ—¶é—´
 327   1        // Whaiting for bat. output by manule
 328   1        SHORT_ON;
 329   1        Timer0_Delay1ms(300); //ä¿ç•™çœ‹ç”µæµçš„æ—¶é—´
 330   1        SHORT_OFF;
 331   1      
 332   1        set_ADCEN; clr_ADCF;
 333   1        set_ADCS; set_ADCEN;
 334   1        //æ­¤æ—¶ç”µå‹å€¼ > 4.8V < 8V,æŒç»­1ç§’é’Ÿï¼Œè¡¨ç¤ºBAT,OK
 335   1        bat_out_ok =0;
 336   1        while(~bat_out_ok);
 337   1       SHORT_ON;             // shorted
 338   1        Timer0_Delay1ms(2000); //ä¿ç•™çœ‹ç”µæµçš„æ—¶é—´
 339   1      
 340   1        get_current_ok = 0;
 341   1        timer0_monitor_start();
 342   1        send_cmd();
 343   1              while(~get_current_ok && ~time_out);    // Waiting A meter return
 344   1        timer0_monitor_stop();
 345   1        if(time_out){
 346   2              pass= 0;
 347   2        }
 348   1        if(get_current_ok){
 349   2              tempV = current_val[5]; tempV <<= 8; tempV |= (current_val[4] & 0xFF);
 350   2        } 
 351   1        //tempV = 0x0003;
 352   1        //pass = 1;
 353   1        if(~pass || tempV > 0x0014){  // < 0.02A
 354   2              Timer0_Delay1ms(1500); //ä¿ç•™çœ‹ç”µæµçš„æ—¶é—´ 1500ms *2 =3s
 355   2          pass = 0; do_a_judgement(); SHORT_OFF; return; // ---> return (ng shorted cancel)
 356   2        }
 357   1      
 358   1      
 359   1        // ----------------------------------------------- Output Recovery
C51 COMPILER V9.02   MAIN                                                                  06/24/2018 09:18:16 PAGE 7   

 360   1        /*
 361   1        CHARGE_ON;            //åˆ©ç”¨ï¼ˆADC: testing ==1 || P13 ==0) 
 362   1        Timer0_Delay1ms(1500); //ä¿ç•™çœ‹ç”µæµçš„æ—¶é—´ 1500ms *2 =3s
 363   1       set_ADCEN; clr_ADCF;
 364   1        set_ADCS; set_ADCEN;
 365   1        //æ­¤æ—¶ç”µå‹å€¼ > 4.8V < 8V,æŒç»­1ç§’é’Ÿï¼Œè¡¨ç¤ºBAT,OK
 366   1        recovery_ok =0;
 367   1        while(~recovery_ok);
 368   1        if(~pass){  // < 0.02A
 369   1              Timer0_Delay1ms(1500); //ä¿ç•™çœ‹ç”µæµçš„æ—¶é—´ 1500ms *2 =3s
 370   1          pass = 0; do_a_judgement(); SHORT_OFF; return; // ---> return (ng shorted cancel)
 371   1        }   
 372   1              */
 373   1        SHORT_OFF; //OK shorted cancel
 374   1        do_a_judgement();
 375   1      }
 376          
 377          void sys_reset(){
 378   1              set_SWRST;      
 379   1      }
 380          
 381          void ng_relay_reset(){
 382   1              NG_OFF;
 383   1      }
 384          
 385          
 386          /*
 387          æµç¨‹è¯´æ˜ï¼š
 388          ä¸Šç”µæ£€æŸ¥æœ‰æ²¡æœ‰è¾“å‡º
 389          è¾“å‡ºæœ‰ï¼Œç”¨relay æ¥ä¸Šç”µæ± 
 390          ç­‰å¾…8ç§’ ï¼ˆå¸¸é‡ï¼‰
 391          */
 392          void main(){
 393   1              // åˆå§‹åŒ–
 394   1              ioConf();       
 395   1              OK_OFF;
 396   1              NG_OFF;
 397   1              SHORT_OFF;
 398   1              CHARGE_ON;
 399   1        Timer0_Delay1ms(1000);
 400   1      
 401   1              set_ES;
 402   1              set_REN;
 403   1              set_EADC;
 404   1      
 405   1      
 406   1              clr_ADCF;
 407   1              set_ADCEN;
 408   1              set_ADCS;
 409   1      
 410   1              set_EA; 
 411   1      
 412   1      
 413   1              InitialUART0_Timer1(115200);
 414   1              //InitialUART1_Timer3(115200);
 415   1      
 416   1              while (1){
 417   2                      //if(~testing && power_on){
 418   2                      if(power_on){
 419   3                              testing = 1;  // æ ‡è®°è¿›å…¥æµ‹è¯•ä¸­
 420   3                              clr_ADCEN;
 421   3                              test_flow();
C51 COMPILER V9.02   MAIN                                                                  06/24/2018 09:18:16 PAGE 8   

 422   3                      }
 423   2                      Timer0_Delay1ms(500);
 424   2      
 425   2                      if(P03 == 0){
 426   3                              ng_reset();
*** WARNING C206 IN LINE 426 OF CODE\MAIN.C: 'ng_reset': missing function-prototype
 427   3                      }
 428   2      
 429   2                      if(P04 == 0) {
 430   3                              sys_reset();
 431   3                      }
 432   2              
 433   2              }
 434   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1053    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     14    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
